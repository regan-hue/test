# 相机参数计算说明

## 概述

本文档说明如何根据一组3D点计算MPR（多平面重建）视图的相机参数，以便在三个视图中显示这些点所在的平面。

## 相机参数说明

在Cornerstone.js中，每个viewport的相机包含以下关键参数：

1. **Position（相机位置）**: 相机在世界坐标系中的位置 `[x, y, z]`
2. **Focal Point（焦点）**: 相机看向的目标点 `[x, y, z]`
3. **View Up（视图向上方向）**: 定义视图的"向上"方向 `[x, y, z]`
4. **Parallel Scale（平行缩放）**: 平行投影的缩放比例（单位：mm）
5. **View Angle（视角）**: 透视投影的视角（单位：度）

## 计算步骤

### 1. 计算点的边界框（Bounding Box）

首先计算所有点的最小和最大坐标：

```javascript
function calculateBounds(points) {
  let minX = Infinity, maxX = -Infinity
  let minY = Infinity, maxY = -Infinity
  let minZ = Infinity, maxZ = -Infinity

  points.forEach(point => {
    minX = Math.min(minX, point[0])
    maxX = Math.max(maxX, point[0])
    minY = Math.min(minY, point[1])
    maxY = Math.max(maxY, point[1])
    minZ = Math.min(minZ, point[2])
    maxZ = Math.max(maxZ, point[2])
  })

  return {
    min: [minX, minY, minZ],
    max: [maxX, maxY, maxZ],
    size: [maxX - minX, maxY - minY, maxZ - minZ],
    center: [(minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2]
  }
}
```

### 2. 计算平面法向量

使用最小二乘法或三点法计算平面法向量：

```javascript
function calculatePlaneNormal(points) {
  // 方法1: 使用三点计算法向量
  const p1 = points[0]
  const p2 = points[Math.floor(points.length / 3)]
  const p3 = points[Math.floor(points.length * 2 / 3)]

  const v1 = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]]
  const v2 = [p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2]]

  // 计算叉积得到法向量
  const normal = [
    v1[1] * v2[2] - v1[2] * v2[1],
    v1[2] * v2[0] - v1[0] * v2[2],
    v1[0] * v2[1] - v1[1] * v2[0]
  ]

  // 归一化
  const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2])
  if (length > 0) {
    normal[0] /= length
    normal[1] /= length
    normal[2] /= length
  }

  return normal
}
```

### 3. 计算各视图的相机参数

#### 轴向视图（Axial）

轴向视图是从上往下看（沿Z轴方向）：

```javascript
const bounds = calculateBounds(points)
const maxRange = Math.max(bounds.size[0], bounds.size[1], bounds.size[2])

const axialCamera = {
  position: [bounds.center[0], bounds.center[1], bounds.center[2] + maxRange * 0.5],
  focalPoint: bounds.center,
  viewUp: [0, -1, 0],  // Y轴向下（DICOM标准）
  parallelScale: maxRange * 1.2,  // 添加20%边距
  viewAngle: 90.0
}
```

**解释**:
- `position`: 相机位于平面中心上方，Z坐标增加
- `focalPoint`: 看向平面中心
- `viewUp`: `[0, -1, 0]` 表示Y轴向下（DICOM标准）
- `parallelScale`: 根据点的范围设置，确保所有点都可见

#### 矢状视图（Sagittal）

矢状视图是从侧面看（沿X轴方向）：

```javascript
const normal = calculatePlaneNormal(points)
// 计算viewUp向量（垂直于法向量和X轴）
const viewRight = [1, 0, 0]
const viewUp = [
  normal[1] * viewRight[2] - normal[2] * viewRight[1],
  normal[2] * viewRight[0] - normal[0] * viewRight[2],
  normal[0] * viewRight[1] - normal[1] * viewRight[0]
]
// 归一化viewUp
const upLength = Math.sqrt(viewUp[0]**2 + viewUp[1]**2 + viewUp[2]**2)
viewUp[0] /= upLength
viewUp[1] /= upLength
viewUp[2] /= upLength

const sagittalCamera = {
  position: [bounds.center[0] + maxRange * 0.5, bounds.center[1], bounds.center[2]],
  focalPoint: bounds.center,
  viewUp: viewUp,
  parallelScale: maxRange * 1.2,
  viewAngle: 90.0
}
```

**解释**:
- `position`: 相机位于平面中心右侧，X坐标增加
- `focalPoint`: 看向平面中心
- `viewUp`: 根据平面法向量计算，确保视图方向正确
- `parallelScale`: 根据点的范围设置

#### 冠状视图（Coronal）

冠状视图是从前面看（沿Y轴方向）：

```javascript
const coronalCamera = {
  position: [bounds.center[0], bounds.center[1] - maxRange * 0.5, bounds.center[2]],
  focalPoint: bounds.center,
  viewUp: [0, 0, 1],  // Z轴向上
  parallelScale: maxRange * 1.2,
  viewAngle: 90.0
}
```

**解释**:
- `position`: 相机位于平面中心前方，Y坐标减少
- `focalPoint`: 看向平面中心
- `viewUp`: `[0, 0, 1]` 表示Z轴向上
- `parallelScale`: 根据点的范围设置

## 实际示例

根据您提供的点数据（`less_points`），计算出的相机参数如下：

### 轴向视图参数

```
相机位置: [151.14, -177.80, 732.99]
焦点: [26.38, -177.80, 859.10]
视图向上: [0.00, -1.00, 0.00]
平行缩放: 109.79 mm
视角: 90.00°
```

**计算逻辑**:
- 焦点位于点的中心附近：`[26.38, -177.80, 859.10]`
- 相机位置在焦点上方（Z方向）：`[151.14, -177.80, 732.99]`
- 注意：这里Z坐标减小是因为相机在"上方"看向下方
- 平行缩放设置为109.79mm，确保所有点都可见

### 矢状视图参数

```
相机位置: [150.23, -177.80, 989.05]
焦点: [24.13, -177.80, 864.30]
视图向上: [-0.70, 0.00, 0.71]
平行缩放: 87.79 mm
视角: 90.00°
```

**计算逻辑**:
- 焦点位于点的中心：`[24.13, -177.80, 864.30]`
- 相机位置在焦点右侧（X方向）：`[150.23, -177.80, 989.05]`
- 视图向上向量 `[-0.70, 0.00, 0.71]` 是根据平面法向量计算的，确保视图方向正确
- 平行缩放设置为87.79mm

### 冠状视图参数

```
相机位置: [22.20, -332.58, 864.00]
焦点: [22.20, -155.20, 864.00]
视图向上: [0.00, 0.00, 1.00]
平行缩放: 85.80 mm
视角: 90.00°
```

**计算逻辑**:
- 焦点位于点的中心：`[22.20, -155.20, 864.00]`
- 相机位置在焦点前方（Y方向减小）：`[22.20, -332.58, 864.00]`
- 视图向上向量 `[0.00, 0.00, 1.00]` 表示Z轴向上
- 平行缩放设置为85.80mm

## Parallel Scale 的计算

`parallelScale` 决定了视图的缩放级别。它表示视图中可见区域的高度（或宽度，取决于视图方向）。

计算公式：

```javascript
const bounds = calculateBounds(points)
const maxRange = Math.max(bounds.size[0], bounds.size[1], bounds.size[2])
const parallelScale = maxRange * 1.2  // 添加20%边距
```

对于您的点数据：
- X方向范围：约 15.86 mm
- Y方向范围：约 26.85 mm  
- Z方向范围：约 16.17 mm
- 最大范围：26.85 mm
- 添加边距后：约 32-110 mm（根据视图方向调整）

## 注意事项

1. **坐标系**: DICOM使用右手坐标系，Y轴向下，Z轴向后
2. **View Up方向**: 必须与视图方向垂直
3. **Parallel Scale**: 需要根据点的实际分布调整，确保所有点都可见
4. **相机距离**: 相机位置到焦点的距离影响视图的缩放，但平行投影主要受`parallelScale`控制

## 代码实现

完整的实现代码在 `CrosshairsViewer.vue` 中的以下函数：

- `calculatePlaneFromPoints()`: 计算平面参数
- `calculateBounds()`: 计算边界框
- `calculateCameraParamsForView()`: 计算特定视图的相机参数
- `showPointsPlane()`: 应用相机参数到三个视图

## 使用方式

点击"📐 显示点平面"按钮，系统会自动将三个视图的相机参数设置为显示这些点所在平面的最佳视角。

