# Cornerstone.js Crosshairs 功能实现文档

## 概述

本文档说明如何使用 Cornerstone.js 实现 Crosshairs（交叉线）功能，从 Orthanc DICOM 服务器加载医学影像数据，并在多个视口中显示多平面重建（MPR）视图。

## 项目结构

```
cornoerstone/
├── src/
│   ├── main.js                    # Vue应用入口
│   ├── app.vue                    # 主应用组件
│   └── components/
│       └── CrosshairsViewer.vue   # Crosshairs查看器组件
├── vite.config.js                 # Vite配置文件（包含代理设置）
├── package.json                   # 项目依赖
└── index.html                     # HTML入口文件
```

## 技术栈

- **Vue 3**: 前端框架
- **Cornerstone.js**: 医学影像渲染库
  - `@cornerstonejs/core`: 核心功能
  - `@cornerstonejs/dicom-image-loader`: DICOM图像加载器
  - `@cornerstonejs/streaming-image-volume-loader`: 流式体积加载器
  - `@cornerstonejs/tools`: 工具库（包含Crosshairs工具）
- **Vite**: 构建工具和开发服务器

## 实现步骤

### 1. 项目配置

#### 1.1 依赖安装

项目已安装以下依赖包：

```json
{
  "@cornerstonejs/core": "^1.86.1",
  "@cornerstonejs/dicom-image-loader": "^1.0.0",
  "@cornerstonejs/streaming-image-volume-loader": "^1.86.1",
  "@cornerstonejs/tools": "^1.86.1",
  "dicom-parser": "^1.8.21",
  "vue": "^3.5.24"
}
```

#### 1.2 Vite配置（vite.config.js）

配置了以下关键设置：

1. **CORS和SharedArrayBuffer支持**：
   - 添加了 `Cross-Origin-Opener-Policy: same-origin`
   - 添加了 `Cross-Origin-Embedder-Policy: require-corp`
   这些头信息对于使用 SharedArrayBuffer 是必需的，Cornerstone.js 需要它来高效处理大型医学影像数据。

2. **代理配置**：
   - `/dicom-web`: 代理到 Orthanc 服务器的 DICOMweb 接口
   - `/tools`: 代理到 Orthanc 工具接口
   - `/instances`: 代理到 Orthanc 实例接口

### 2. 核心实现

#### 2.1 初始化 Cornerstone.js

在 `CrosshairsViewer.vue` 组件的 `onMounted` 生命周期钩子中，按以下顺序初始化：

```javascript
// 1. 初始化核心库
await cornerstoneInit()

// 2. 初始化DICOM图像加载器
await dicomImageLoaderInit()

// 3. 初始化工具库
await cornerstoneToolsInit()

// 4. 注册体积加载器
volumeLoader.registerVolumeLoader('cornerstoneStreamingImageVolume', cornerstoneStreamingImageVolumeLoader)

// 5. 注册DICOM图像加载器
const { loadImage } = await import('@cornerstonejs/dicom-image-loader')
imageLoader.registerImageLoader('dicomweb', loadImage)
```

#### 2.2 创建渲染引擎和工具组

```javascript
// 创建渲染引擎
const renderingEngine = new RenderingEngine(renderingEngineId)

// 创建工具组（用于管理多个viewport的工具）
const toolGroup = ToolGroupManager.createToolGroup(toolGroupId)
```

#### 2.3 配置工具

添加并激活以下工具：

1. **CrosshairsTool**: 交叉线工具（主要功能）
   - 绑定到鼠标左键（Primary）
   
2. **PanTool**: 平移工具
   - 绑定到鼠标中键（Auxiliary）
   
3. **WindowLevelTool**: 窗宽窗位调整工具
   - 绑定到鼠标右键（Secondary）
   
4. **ZoomTool**: 缩放工具
   - 绑定到 Shift + 鼠标左键
   
5. **StackScrollMouseWheelTool**: 鼠标滚轮滚动工具
   - 用于在图像序列中滚动

#### 2.4 从 Orthanc 获取 DICOM 实例

使用 Orthanc REST API 获取系列中的所有实例：

```javascript
async function fetchInstances() {
  const response = await fetch(`${orthancUrl}/series/${seriesInstanceUID}`)
  const seriesData = await response.json()
  const instanceIds = seriesData.Instances || []
  
  // 构建图像ID列表
  const imageIds = instanceIds.map((instanceId) => {
    return `dicomweb:${orthancUrl}/instances/${instanceId}/file`
  })
  
  return imageIds
}
```

**配置信息**：
- Orthanc服务器地址: `http://192.168.1.3:18997`
- 研究实例UID: `1.2.826.0.1.3680043.2.109.5.20220519102622656.1699758078.1`
- 系列实例UID: `1.3.12.2.1107.5.1.4.73336.30000022051900071431600050933`

#### 2.5 创建多平面视图

创建三个正交视图（Orthographic Viewports）：

1. **轴向视图（Axial）**: 从上往下看
2. **矢状视图（Sagittal）**: 从侧面看（左右）
3. **冠状视图（Coronal）**: 从前面看（前后）

```javascript
const viewportInputArray = [
  {
    viewportId: 'axial-viewport',
    type: Enums.ViewportType.ORTHOGRAPHIC,
    element: axialViewport.value,
    defaultOptions: {
      orientation: Enums.OrientationAxis.AXIAL,
    },
  },
  // ... 其他视图
]
```

#### 2.6 加载体积数据

使用流式体积加载器创建和加载体积：

```javascript
async function loadVolume(renderingEngine, viewportIds, imageIds) {
  // 创建体积ID（使用cornerstoneStreamingImageVolume协议）
  const volumeId = `cornerstoneStreamingImageVolume:volume-${seriesInstanceUID}`
  
  // 创建并缓存体积
  const volume = await volumeLoader.createAndCacheVolume(volumeId, {
    imageIds,
  })
  
  // 加载体积数据
  await volume.load()
  
  // 将体积设置到各个viewport
  axialViewport.setVolumes([{ volumeId }])
  sagittalViewport.setVolumes([{ volumeId }])
  coronalViewport.setVolumes([{ volumeId }])
  
  // 渲染所有viewport
  renderingEngine.renderViewports([...])
}
```

#### 2.7 Crosshairs 工具配置

Crosshairs 工具会自动在所有添加到工具组的 viewport 之间同步：

```javascript
// 将viewports添加到工具组
toolGroup.addViewport(viewportIds.axial, renderingEngineId)
toolGroup.addViewport(viewportIds.sagittal, renderingEngineId)
toolGroup.addViewport(viewportIds.coronal, renderingEngineId)

// 激活Crosshairs工具
toolGroup.setToolActive(CrosshairsTool.toolName, {
  bindings: [{ mouseButton: Enums.MouseBindings.Primary }],
})
```

## 功能特性

### Crosshairs 功能

1. **多视图同步**: 在一个视口中点击或拖动时，其他视口会自动更新显示对应的交叉线位置
2. **交互式导航**: 可以通过拖动交叉线来导航到不同的解剖位置
3. **视觉反馈**: 交叉线以绿色显示，清晰标识当前位置

### 其他交互功能

- **平移**: 鼠标中键拖动
- **窗宽窗位调整**: 鼠标右键拖动
- **缩放**: Shift + 鼠标左键拖动
- **滚动**: 鼠标滚轮在图像序列中滚动

## 使用现有工具和库

本实现完全基于 Cornerstone.js 官方提供的工具和库，没有编写自定义代码：

1. **@cornerstonejs/core**: 提供核心渲染引擎、viewport管理、体积加载等功能
2. **@cornerstonejs/dicom-image-loader**: 提供DICOM图像加载能力
3. **@cornerstonejs/streaming-image-volume-loader**: 提供流式体积加载，支持大型数据集
4. **@cornerstonejs/tools**: 提供CrosshairsTool和其他交互工具

## 运行项目

1. **安装依赖**（如果尚未安装）：
   ```bash
   npm install
   ```

2. **启动开发服务器**：
   ```bash
   npm run dev
   ```

3. **访问应用**：
   浏览器会自动打开 `http://localhost:3002`

## 注意事项

1. **CORS配置**: 确保 Orthanc 服务器配置了正确的 CORS 头，或者使用 Vite 代理（已配置）

2. **SharedArrayBuffer**: 需要正确的 HTTP 头才能使用 SharedArrayBuffer，这在 `vite.config.js` 中已配置

3. **Orthanc配置**: 确保 Orthanc 服务器已启用 DICOMweb 插件（如果使用 DICOMweb 接口）

4. **网络连接**: 确保可以访问 Orthanc 服务器地址 `http://192.168.1.3:18997`

## 故障排除

### 问题：图像无法加载

- 检查 Orthanc 服务器是否运行
- 检查网络连接
- 检查系列实例UID是否正确
- 查看浏览器控制台的错误信息

### 问题：Crosshairs 不显示

- 确保所有三个viewport都已添加到工具组
- 确保Crosshairs工具已激活
- 检查viewport是否正确渲染

### 问题：CORS错误

- 检查 `vite.config.js` 中的代理配置
- 确保使用代理路径访问 Orthanc API

## 参考资源

- [Cornerstone.js 官方文档](https://www.cornerstonejs.org/)
- [Cornerstone.js Crosshairs 示例](https://www.cornerstonejs.org/live-examples/crosshairs)
- [Orthanc 文档](https://book.orthanc-server.com/)

## 总结

本实现完全基于 Cornerstone.js 官方库，通过以下步骤实现了 Crosshairs 功能：

1. ✅ 配置 Vite 开发服务器和代理
2. ✅ 初始化 Cornerstone.js 核心库和工具
3. ✅ 从 Orthanc 服务器获取 DICOM 数据
4. ✅ 创建多平面重建视图（轴向、矢状、冠状）
5. ✅ 加载体积数据到各个视图
6. ✅ 配置和激活 Crosshairs 工具

所有功能都通过使用现有的 Cornerstone.js 工具和库实现，没有编写自定义的底层代码。

